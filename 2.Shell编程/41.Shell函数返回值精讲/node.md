# Shell函数返回值精讲
在C++、Java、C#、Python等大部分的编程语言中，返回值是指函数被调用之后，执行函数体中的代码所得到的结果，这个结果就通过return语句返回。

但是Shell中的返回值表示的是函数的退出状态：返回值为0表示函数成功执行了，返回值为非0表示函数执行失败（出错）了，if、while、for等语句都是根据函数的退出状态来判断条件是否成立。

**Shell 函数的返回值只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败。**

函数执行失败时，可以根据返回值（退出状态）来判断具体出现了什么错误，比如一个打开文件的函数，我们可以指定 1 表示文件不存在，2 表示文件没有读取权限，3 表示文件类型不对。

如果函数体中没有 return 语句，那么使用默认的退出状态，也就是最后一条命令的退出状态。如果这就是你想要的，那么更加严谨的写法为：
```shell
return $?
```
`$?`是一个特殊变量，用来获取上一个命令的退出状态，或者上一个函数的返回值。

# 如何获得函数的处理结果
既然return表示退出状态，那么该如何得到函数的处理结果呢？比如，我定义了一个函数，计算从m加到n的和，最终得到的结果改如何返回呢？

这个问题有两种解决方案：
+ 一种是借助全局变量，将得到的结果赋值给全局变量；
+ 另一种是在函数内部使用echo、printf命令将结果输出，在函数外使用`$()`或者&#96; &#96;捕获结果

下面我们具体来定义一个函数 getsum，计算从 m 加到 n 的和，并使用以上两种解决方案。

【实例1】将函数处理结果赋值给一个全局变量
```shell
#!/bin/bash

sum=0 #全局变量

function getsum() {
     for (( i = $1; i <=$2; i++ )); do
         ((sum+=i))
     done

     return $? # 返回上一条命令的退出状态
}

read m
read n

if getsum $m $n; then # 调用函数
   echo "The sum is $sum"  #输出全局变量
else
  echo "Error!"
fi
```
运行结果：
```shell
1
100
The sum is 5050
```
这种方案的弊端是：定义函数的同时还得额外定义一个全局变量，如果我们仅仅知道函数的名字，但是不知道全局变量的名字，那么也是无法获取结果的。

【实例2】在函数内部使用echo输出结果
```shell
#!/bin/bash

function getsum() {
    local sum=0 # 局部变量
    for (( i = $1; i <= $2; i++ )); do
        ((sum+=i))
    done
    echo $sum
    return $?
}

read m
read n

total=$(getsum $m $n)
echo "The sum is $total"


#也可以省略 total 变量，直接写成下面的形式
#echo "The sum is "$(getsum $m $n)
```
运行结果：
```shell
1
100
The sum is 5050
```
代码中总共执行了两次 echo 命令，但是却只输出一次，这是因为`$()`捕获了第一个 echo 的输出结果，它并没有真正输出到终端上。除了`$()`，
你也可以使用&#96; &#96;来捕获 echo 的输出结果。

这种方案的弊端是：如果不使用`$()`，而是直接调用函数，那么就会将结果直接输出到终端上，不过这貌似也无所谓，所以我推荐这种方案。

总起来说，虽然C语言、C++、Java 等其它编程语言中的返回值用起来更加方便，但是 Shell 中的返回值有它独特的用途，所以不要带着传统的编程思维来看待 Shell 函数的返回值。
