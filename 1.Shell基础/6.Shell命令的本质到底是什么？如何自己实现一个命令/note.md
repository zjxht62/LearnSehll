# Shell命令的本质到底是什么？如何自己实现一个命令？
用户通过在 Shell 中输入一些命令来使用 Linux。给命令附带不同的选项后，同一个命令的功能也会有所差异。

Shell命令分为两种：
+ Shell 自带的命令称为内置命令，它在 Shell 内部可以**通过函数来实现**，当 Shell 启动后，**这些命令所对应的代码（函数体代码）也被加载到内存中**，
所以使用内置命令是非常快速的。
+ 更多的命令是外部的应用程序，一个命令就对应一个应用程序。运行外部命令要开启一个新的进程，所以效率上比内置命令差很多。

用户输入一个命令后，Shell 先检测该命令是不是内置命令，如果是就执行，如果不是就检测有没有对应的外部程序：有的话就转而执行外部程序，
执行结束后再回到 Shell；没有的话就报错，告诉用户该命令不存在。

# 内置命令
内置命令不宜过多，过多的内置命令会导致 Shell 程序本身体积膨胀，运行 Shell 程序后就会占用更多的内存。Shell 是一个常驻内存的程序，
占用过多内存会影响其它的程序。

只有那些最常用的命令才有理由成为内置命令，比如 cd、kill、echo 等；

# 外部命令

应用程序就是一个文件，只不过这个文件是可以执行的。既然是文件，那么它就有一个名字，并且存放在文件系统中。用户在 Shell 中输入一个外部命令后，
只是将可执行文件的名字告诉了 Shell，但是并没有告诉 Shell 去哪里寻找这个文件。

为了解决这个问题，**Shell 在启动文件中增加了一个叫做 PATH 的环境变量**，该变量就保存了 **Shell 对外部命令的查找路径**，
如果在这些路径下找不到同名的文件，Shell 也不会再去其它路径下查找了，它就直接报错。

我们使用 echo 命令输出 PATH 变量的值，看看它保存了哪些检索路径：
```shell
[root@zntsa ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/local/java/jdk-8u333-linux-x64/jdk1.8.0_333/bin:/usr/local/java/jdk-8u333-linux-x64/jdk1.8.0_333/jre/bin:/root/bin:/root/.local/bin
```
不同的路径之间以`:`分隔。你看，Shell 只会在几个固定的路径中查找外部命令。

如果我们自己用C语言或者 C++ 编写一个应用程序，并将它放到这几个目录下面，那么我们的程序也会成为 Shell 命令。
当然，你也可以修改 PATH 变量给它增加另外的路径

# 总结
Shell 内置命令的本质是一个自带的函数，执行内置命令就是调用这个自带的函数。因为函数代码在 Shell 启动时已经被加载到内存了，所以内置命令的执行速度很快。

Shell 外部命令的本质是一个应用程序，执行外部命令就是启动一个新的应用程序。因为要创建新的进程并加载应用程序的代码，所以外部命令的执行速度很慢。
