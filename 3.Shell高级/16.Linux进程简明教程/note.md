# Linux进程简明教程
进程是Linux操作系统中最重要的基本概念之一，这一节我们将了解学习Linux进程的一些基础知识。

进程是运行在Linux中的程序的一个实例。

当你在Linux系统中执行一个程序时，系统会为这个程序创建特定的环境。这个环境包含系统运行这个程序所需的任何东西。

每当你在Linux中执行一个命令，它都会创建，或启动一个新的进程。比如，当你尝试运行命令”ls -l“来列出目录的内容时，你就启动了一个进程。如果有两个终端窗口显示在屏幕上，
那么你可能运行了两次同样的终端程序，这时会有两个终端进程。

每个终端窗口可能都运行了一个Shell，每个运行的Shell都分别是一个进程。当你从Shell调用一个命令时，对应的程序就会在一个新进程中执行，当这个程序的进程执行完成后，Shell的进程将恢复运行。

操作系统通过被称为 PID 或进程 ID 的数字编码来追踪进程。系统中的每一个进程都有一个唯一的 PID。

现在我们通过一个实例来了解 Linux 中的进程。我们在 Shell 命令行下执行如下命令：
```shell
[root@zntsa 16.Linux进程简明教程]# sleep 10 &
[1] 22209
```
因为程序会等待 10 秒，所以我们快速地在当前 Shell 上查找任何进程名为 sleep 的进程：
```shell
[root@zntsa 16.Linux进程简明教程]# ps -ef | grep sleep
root     22209 22155  0 14:03 pts/0    00:00:00 sleep 10
root     22215 22155  0 14:03 pts/0    00:00:00 grep --color=auto sleep
```
我们看到进程名为 /usr/bin/sleep 的进程正运行在系统中（其 PID 与我们在上一命令中得到的 PID 相同）。

现在，我们尝试并行地从 3 个不同的终端窗口运行上述的 sleep 命令，上述命令的输出将类似如下所示：
```shell
[c.biancheng.net]$ ps -ef | grep sleep
mozhiyan  896   5712  cons1  17:16:51  /usr/bin/sleep
mozhiyan  5924  5712  cons1  17:16:52  /usr/bin/sleep
mozhiyan  2424  5712  cons1  17:16:50  /usr/bin/sleep
```
我们看到 sleep 程序的每一个实例都创建了一个单独的进程。

每一个Linux进程还有另外一个ID号码，即父进程的ID(ppid)。系统中的每一个用户进程都有一个父进程。

命令`ps -f`就会列出进程的PID和PPID。此命令的输出类似如下所示：
```shell
[root@zntsa ~]# ps -f
UID        PID  PPID  C STIME TTY          TIME CMD
root     22412 21670  0 14:06 pts/3    00:00:00 -bash
root     22562 22412  0 14:08 pts/3    00:00:00 ps -f
```

你在Shell命令行提示符下运行的命令都把当前Shell的进程作为父进程。例如，你在Shell命令行提示符下输入ls命令，Shell将执行ls命令，此时Linux内核会复制Shell的内存页，然后执行ls命令。

在 Unix 中，每一个进程是使用 fork 和 exec 方法创建的。然而，这种方法会导致系统资源的损耗。

在Linux中，fork方法是使用写时拷贝内存页实现的，所以它导致的仅是时间和复制父进程的内存页表所需的内存的损失，并且会为子进程创建一个唯一的任务结构。

写时拷贝模式在创建新进程时避免了创建不必要的结构拷贝。例如，用户在Shell命令行提示符下输入ls命令，Linux内核将会创建一个Shell的子进程，即Shell的进程是父进程，
而ls命令的进程是子进程，ls命令的进程会指向与此Shell相同的内存页，然后子进程使用写时拷贝技术执行ls命令。

# 前台进程和后台进程
当你启动一个进程时（运行一个命令），可以如下两种方式运行该进程：
+ 前台进程
+ 后台进程

默认情况下，你启动的每一个进程都是运行在前台的。它从键盘获取输入并发送它的输出到屏幕。

当一个进程运行在前台时，我们不能在同一命令行提示符下运行任何其他命令（启动任何其他进程），因为在程序结束它的进程之前命令行提示符不可用。

启动一个后台进程最简羊的方法是添加一个控制操作符“&”到命令的结尾。例如，如下命令将启动一个后台进程：
```shell
[root@zntsa ~]# sleep 10 &
[1] 22479
```
现在 sleep 命令被放在后台运行。当 Bash 在后台启动一个作业时，它会打印一行内容显示作业编号（[1]）和进程号（PID-5720）。当作业完成时，作业会发送类似如下的信息到终端程序，来显示此作业已完成，其内容类似如下所示：
```shell
[1]+ Done    sleep 10
```
将进程放在后台运行的好处是：你可以继续运行其他命令，而不需要等待此进程运行完成再运行其他命令。

# 进程的状态
每个Linux进程都有它自己的生命周期，比如，创建、执行、结束和清除。每个进程也都有各自的状态，显示进程中当前正发生什么。

进程可以有如下几种状态：
+ D（不可中断休眠状态）——进程正在休眠并且不能恢复，直到一个事件发生为止。
+ R（运行状态）——进程正在运行。
+ S（休眠状态）——进程没有在运行，而在等待一个事件或是信号。
+ T（停止状态）——进程被信号停止，比如，信号 SIGINT 或 SIGSTOP。
+ Z（僵死状态）——标记为 <defunct> 的进程是僵死的进程，它们之所以残留是因为它们的父进程适当地销毁它们。如果父进程退出，这些进程将被 init 进程销毁。

若要查看指定进程的状态，可以使用如下命令：
```shell
ps -C processName -o pid=,cmd,stat
```
例如：
```shell
[root@zntsa ~]# ps -C sleep -o pid=,cmd,stat
      CMD                         STAT
23901 sleep 30                    S
```

